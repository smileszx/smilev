###发号器

#### 1.1 可选技术方案

##### 1.1.1 UUID

- 优点： UUID保证ID唯一性
- 缺点：
>无法满足业务系统需求如 （1）时间错略有序性（2）可反解（3）可制造性

>其他问题 （1）UUID 比较长、占用空间大、导致数据库性能下降 （2）UUID不具备有序性，导致B+树索引写操作随机
（3）写操作不能产生有序append操作，需要进行insert，读取整个B+树节点到内存，插入记录将整个节点写回磁盘，这种操作方式在记录占用空间比较大的情况，性能下降明显。

##### 1.1.2 数据库实现

业务系统的ID使用数据库自增字段，而我们知道自增字段完全依赖数据库，当进行数据库移植、扩容、系数据、分库分表等操作会带来很多麻烦。

请求量级不断增加，数据库性能瓶颈会出现，有的方案通过设置数据库sequence 或者 表自增字段步长，存在的问题是 （1）服务节点固定，sequence步长固定，当增加节点时难以水平扩展（2）依赖数据库，对数据库造成压力，ID产生是高频访问的服务
（3）多个sequence 是疏散管理，增加人员维护成本

##### 1.1.3 Snowflake 开源项目
Twitter的Snowflake是一个流行的开源发号器实现，互联网广泛使用。Scala语言实现，文档简单，发布模式单一，缺少支持维护，很难；落地。


#### 1.2 分布式系统对发号器的基本需求

在分布式系统中，整体的业务被拆分成多个自治的微服务，每个微服务之间需要通过网络通信交互，由于网络的不确定性，会给系统带来各种不一致的问题。
为避免和解决不一致问题，最重要的模式就是做系统间的实时核对和事后核对，核对的基础就是领域对象及系统间的请求要有唯一ID来标识，核对才能有据可依。

- 全局唯一

> 分布式系统保证全局唯一的悲观策略是使用锁或者分布式锁，但是用锁就会大大降低性能。

> 时间的有序性，且在时间的每个单元下采用自增序列，达到全局唯一

- 粗略有序

> 为解决UUID无序问题，采用粗略有序的方案。（如果做到完全有序，就涉及数据的汇聚，会用到锁或者分布式锁，会影响效率）

> 两种主流方案， （1）秒级有序（2）毫秒级有序

- 可反解 

> ID 附带信息，根据ID的信息反解，存储层省下很多传统的timestamp类的字段占用的空间，有助于定位问题。

- 可制造

> 系统不可能永远不出问题，手工处理的话要求发号器一定支持可复制、可恢复、可制造的特性。

- 高性能

> ID 生成性能取决于网络I/O和CPU性能，网络的I/O一般不是瓶颈，根据经验单台机器TPS应该能达到10000/s

- 高可用
 
 > 发号器必须是一个对等的集群，一台机器挂掉，请求必须能够转发到其他机器，重试机制必不可少。如果远程服务宕机，本地容错方案是高可用的最后一道屏障。
 
 - 可伸缩
 
 > 分布式系统，业务量增长不容忽略，系统需要支持水平伸缩。



























